<!--Written by Max Leon Guwa (OrangePurgatory; https://github.com/OrangePurgatory)-->


<head>
<h1 align="center">Schoolbuddy - Projektseite</h1> 
</head>
<h3 align="center"> Ein Projekt von Lois und Max 11p </h3>
</br>

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/105984356/186677878-5eddbf06-304d-4ea7-90db-5ddba9e40dbf.png">
  <source media="(prefers-color-scheme: light)" srcset="https://user-images.githubusercontent.com/105984356/186676647-16dacef0-4117-4750-afc1-1d4d6409e6d3.png">
  <img alt="" src="">
</picture>


<h3 align="left">Stormarnschule Ahrensburg <br/> Informatik, Buhl <br/> Schuljahr 2022/23, 2. Halbjahr </br> </h3> </div>
<h3 align="left"> &#10132; <a href="https://github.com/LoMaTiInformatik/SchoolBuddy/blob/main/docs/Projekttagebuch.md"> Projekttagebuch</a> </h3> 
</br>

<h2>Inhalt</h2>
<p><a href="#kapitell">1. Einleitung</a></p>
<p><a href="#kapitel2">2. Vorstellung des Projekts</a></p>
<p><a href="#kapitel3">3. Erklärung des Codes</a></p>
<p><a href="#main.py">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main.py</a></p>
<p><a href="#utils">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utils</a></p>
<p><a href="#befehle">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Befehle</a></p>
<p><a href="#kapitel4">4. Entstehung des Projekts</a></p>
<p><a href="#kapitel5">5. Fazit</a></p>
<p><a href="#kapitel6">6. Quellen</a></p>
<p><a href="#kapitel7">7. Eigenständigkeitserklärung</a></p>
<br>


<h2 id="kapitell">1. Einleitung</h2>
<p>Hallo und herzlich willkommen zu unserer Projektseite für unser Projekt. Hier erklären wir das Verfahren, unsere Ideen und erklären das Endprodukt.</br>
<a href="https://github.com/LoMaTiInformatik/SchoolBuddy/blob/main/docs/Projekttagebuch.md"> Hier</a> kommst du zur Protokollseite.</p>


<h2 id="kapitel2">2. Vorstellung des Projekts</h2>
<p>Das Smartphone war und ist schon einiger Zeit unser Alltagshelfter gewesen. Doch manchmal denkt man sich, wieso es denn nicht noch einfacher gehen kann, wie zum Beispiel mit Alltagshelfern, die man noch nicht einmal mit Tasten, sondern mit Sprachsteuerung bedienen kann. Geräte dieser Art existieren schon seit einiger Zeit auf dem Markt, können allerdings einige spezifische Dinge nicht.</p>
<p>Also dachten wir uns, wieso nicht ein Produkt erstellen, welches den Alltag von Schülern und Schülerinnen erleichtert, indem es den Stundenplan von WebUntis nach Sprachaufforderung laut vorließt und man nicht sein Handy herrausholen muss oder den Stundenplan auf den Fernsehern in der Schule prüfen muss.</p>
<p>Aktuell ist das Projekt noch nicht fertiggestellt, also können wir die Funktion des Produktes hier noch nicht zeigen. Dies wird allerdings in unserer nächsten Abgabe hier zu sehen sein.</p>

<details>
  <summary>Bilder zum Projekt</summary>
  Noch keine Bilder vorhanden, da für das Projekt bisher nur ein Computer verwendet wurde.
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="">
      <source media="(prefers-color-scheme: light)" srcset="">
      <img alt="" src="">
    </picture>
  </details>
</br>

<details>
  <summary>Schaltplan</summary>
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://github.com/LoMaTiInformatik/SchoolBuddy/assets/105984356/96e6d178-cf00-460e-85f8-beee85a83a4b">
      <source media="(prefers-color-scheme: light)" srcset="https://github.com/LoMaTiInformatik/SchoolBuddy/assets/105984356/96e6d178-cf00-460e-85f8-beee85a83a4b">
      <img alt="" src="">
  </picture>
</details>
</br>

<details>
  <summary>Funktion (Mindmap)</summary>
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/105984356/236512208-bd00606b-d08e-4d2d-ab62-b8f6c84df860.png">
      <source media="(prefers-color-scheme: light)" srcset="https://user-images.githubusercontent.com/105984356/236512208-bd00606b-d08e-4d2d-ab62-b8f6c84df860.png">
      <img alt="" src="">
    </picture>
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/105984356/236514305-ccc79eb1-daa4-448e-b285-991b4ccb9fea.png">
      <source media="(prefers-color-scheme: light)" srcset="https://user-images.githubusercontent.com/105984356/236514305-ccc79eb1-daa4-448e-b285-991b4ccb9fea.png">
      <img alt="" src="">
    </picture>
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/105984356/236514561-d0a23934-e3af-4de9-985b-94b1baa47fa7.png">
      <source media="(prefers-color-scheme: light)" srcset="https://user-images.githubusercontent.com/105984356/236514561-d0a23934-e3af-4de9-985b-94b1baa47fa7.png">
      <img alt="" src="">
    </picture>
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/105984356/236514763-f15e6bae-5a48-42ad-be04-6634345a3382.png">
      <source media="(prefers-color-scheme: light)" srcset="https://user-images.githubusercontent.com/105984356/236514763-f15e6bae-5a48-42ad-be04-6634345a3382.png">
      <img alt="" src="">
    </picture>
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/105984356/236515004-3c9c6c38-c090-46e0-a5c3-69f6e3fc7ea0.png">
      <source media="(prefers-color-scheme: light)" srcset="https://user-images.githubusercontent.com/105984356/236515004-3c9c6c38-c090-46e0-a5c3-69f6e3fc7ea0.png">
      <img alt="" src="">
    </picture>
  </details>
</details>
</br>

<h2 id="kapitel3">3. Erkärung des Codes</h2>
<p>Zuerst fangen wir mit dem Hauptscript an.</p>
<br>
<h4 id="main.py">main.py</h4>

Erst einmal werden die ganzen benötigten Module importiert.

```py
import os
import logging
from utils.stt import listen
from utils.definitions import handleerror
from utils.speak import speak
from utils.cmdhandler import handlecmd
```

<br>

Die activate Funktion wird deklariert und es wird das Log-Level gesetzt.

```py
def activate():
    # Record audio and handle command
    logging.basicConfig(level=logging.DEBUG, filename="log.txt")
    spkres = listen()
```

<br>

Hier wird das zuhören gestartet. Sobald die listen Funktion etwas zurückgibt wird auf einen Error gecheckt.

```py
    spkres = listen()
    if spkres["error"] != "":
        handleerror(spkres["error"])
        return
```

<br>

Jetzt wird der erkannte Text an die cmdhandle Funktion weitergegeben, um den gewünschten Befehl auszuführen und anschließend den Text der von dem Befehl zurück gegeben wird wiederzugeben.

```py
    cmdres = handlecmd(spkres["value"])
    if cmdres["error"] != "":
        handleerror(cmdres["error"])
        return
    
    speak(cmdres["value"])
```

<br>

<h3 id="utils">Utils</h3>

Die Utils oder auch Utilityscripts sind Skripte, die von vielen Funktionen und anderen Skripten verwendet werden.

<br>

<h4 id="cmdhandler.py">cmdhandler.py</h4>

cmdhandler.py ist das Skript, das herausfindet welcher Befehl gewollt ist und den gesprochenen Text an diesen weitergibt.
<br>
Hier werden alle Befehle die existieren in das Skript geladen.

```py
for x in dir(commands):
    if x.startswith("__"):
        continue

    mod = getattr(commands, x)
    cmdkeywords[x] = {"keywords": mod.keywords}

    logging.debug(str.format("Cmdhandler: Command module {} sucessfully added.", x))
```

<br>

Nun wird die cmdhandle Funktion definiert. Dann wird der gesprochene Text in einzelne Wörter zersetzt und jedes dieser Wörter wird auf die sog. "Keywords" getestet.

```py
def handlecmd(spktext: str):
    typewords = {
        1: {"word": None,
            "weight": 0},
        2: {"word": None,
            "weight": 0},
        3: {"word": None,
            "weight": 0},
        4: {"word": None,
            "weight": 0},
        5: {"word": None,
            "weight": 0}
    }

    # Handle keywords
    for x in spktext.split(" "):
        x = x.lower()
        if x not in keywords:
            continue

        key = keywords[x]
        succ = False

        for y in typewords:
            if typewords[y]["weight"] >= key["weight"]:
                continue

            typewords[y] = {"word": key["typeword"], "weight": key["weight"]}
            succ = True
            break

        else:
            if not succ:
                logging.debug(str.format("CmdHandler: Word {} did not match a keyword.",x))
    else:
        if typewords[1]["word"] == None:
            return {
                "error": "cmdh-1",
                "value": ""
            }
```

<br>

Sobald alle "Keywords" aus dem gesprochenen Text extrahiert wurden, wird bei allen Befehlen geprüft bei welchem Befehl am meisten von diesen "Keywords" übereinstimmen. Dann wird dieser Befehl ausgeführt.

```py
    cmdlist = {}

    for x in cmdkeywords:
        cmdlist[x] = {"times": 0, "weight": 0}
        for y in typewords:
            if not typewords[y]["word"] in cmdkeywords[x]["keywords"]:
                continue

            cmdlist[x]["times"] += 1
            cmdlist[x]["weight"] += typewords[y]["weight"]
        
        else:
            logging.debug(str.format("Cmdhandler: Cmd {} had {} matches with the collective weight of {}.", x, cmdlist[x]["times"], cmdlist[x]["weight"]))
    else:
        if not cmdlist:
            return {
                "error": "cmdh-2",
                "value": ""
            }

    chosencmd = {
        "times": 0,
        "weight": 0,
        "name": ""
    }

    for x in cmdlist:
        if cmdlist[x]["times"] < chosencmd["times"]:
            continue
        elif cmdlist[x]["times"] == chosencmd["times"]:
            if cmdlist[x]["weight"] < chosencmd["weight"]:
                continue
        
        chosencmd["name"] = x
        chosencmd["weight"] = cmdlist[x]["weight"]
        chosencmd["times"] = cmdlist[x]["times"]
    
    else:
        if not chosencmd or chosencmd["name"] == "":
            return {
                "error": "cmdh-3",
                "value": ""
            }

    mod = getattr(commands, chosencmd["name"])

    res = mod.cmdfunction(spktext)
```

<br>

<h4 id="speak.py">speak.py</h4>

speak.py ist für die Sprachausgabe zuständig.

<br>

Erst wird das TTS-Modul importiert, um den Text sprechen zu können. In der speak Funktion wird der eingegebene text in das TTS-Modul gegeben und die resultierende wav abgespielt.

```py
from TTS.api import TTS
import sounddevice as sd

def speak(text):

    """
        Speaks the given text

        Arguments:
        text: Text to speak (str)

        Returns:
        error: Error-Code if any (str)
        value: None (str)
    """

    tts = TTS("tts_models/de/thorsten/tacotron2-DDC")
    wav = tts.tts(text=text)
    sd.play(wav, 23000)
    sd.wait()
    return {
        "error": "",
        "value": ""
    }
```

<br>

<h4 id="stt.py">stt.py</h4>

stt.py ist für die Umwandlung von Sprache in Text zuständig.

<br>

Das Audio wird aufgenommen und an den Google-TTS-Dienst weitergegeben und der resultierende Text wieder zurückgegeben.

```py
import speech_recognition as sr
import logging


def listen():

    """Returns the spoken text."""

    r = sr.Recognizer()

    mic = sr.Microphone()

    logging.warn("Listening")
    with mic as source:
        audio = r.listen(source)

    try:
        # Give audio to google to get text
        text = r.recognize_google(audio, language="de-DE", show_all=False)
        return {
            "error": "",
            "value": text
        }
    except sr.UnknownValueError:
        return {
            "error": "stt-1",
            "value": ""
        }
    except:
        return {
            "error": "stt-2",
            "value": ""
        }
```

<br>

<h4 id="webuntishandler.py">webuntishandler.py</h4>

webuntishandler.py wandelt das Resultat der WebUntis-API in python-verständliche Daten um.

<br>

Die Einstellungen für WebUntis werden aus dem sqlhandler ausgelesen und damit wird das eine WebUntis-Session erstellt.

```py
from utils.sqlhandler import get_settings
import webuntis
import datetime

sett = get_settings()["value"]

# Create session from settings
s = webuntis.Session(
    server=sett["webuserver"],
    username=sett["webuuser"],
    password=sett["webupwd"],
    school=sett["webuschool"],
    useragent="SchoolBuddy"
)
```

<br>

Die Funktion get_lesson_plan wird deklariert. Diese ist dafür zuständlich den Stundenplan des gesamten Tages zu besorgen. Nun wird die vorab eingestellte Klasse definiert und das heutige Datum erschlossen. Mit diesen Informationen wird der Stundenplan dieser bestimmten Zeitspanne erfragt.

```py

def get_lesson_plan(day,sort:bool=True):

    s.login()

    # Get class from settings
    klasse = s.klassen().filter(name=sett["webuclass"])[0]

    start_date = None
    end_date = None
    if (day == "tmrw"):
        curday = datetime.datetime.now() + datetime.timedelta(days=2)
        start_date = datetime.datetime(year=curday.year,month=curday.month,day=curday.day)
        end_date = start_date + datetime.timedelta(hours=23)
    else:
        curday = datetime.datetime.now()
        start_date = datetime.datetime(year=curday.year,month=curday.month,day=curday.day)
        end_date = start_date + datetime.timedelta(hours=23)

    # Get plan for given day
    lesson_plan = s.timetable(klasse=klasse, start=start_date, end=end_date)
```

<br>

Der erhaltene Stundenplan wird hier nach Uhrzeit sortiert und an die ausführende Funktion zurückgegeben.

```py

    if lesson_plan:
        if sort:
            # Sort lessons and return plan
            sorted_lessons = sorted(lesson_plan, key=lambda lesson: lesson.start.strftime("%H:%M"))
            print("Next Lessons:")
            for next_lesson in sorted_lessons:
                subjects = ', '.join([subject.name for subject in next_lesson.subjects])
                rooms = ', '.join([room.name for room in next_lesson.rooms])

                print(f"Subject: {subjects}")
                print(f"Room: {rooms}")
                print(f"Start Time: {next_lesson.start.strftime('%H:%M')}")
                print(f"End Time: {next_lesson.end.strftime('%H:%M')}")
                print()
            
            return {
                "error": "",
                "value": sorted_lessons
            }
        else:
            return {
                "error": "",
                "value": lesson_plan
            }
```

<br>
<h3 id="befehle">Befehle</h3>
<h4 id="lessonplantoday.py">lessonplantoday.py</h4>

Was man zuerst macht, ist den exportierten Stundenplan von dem webuntishandler zu bekommen. Dies macht man wie folgt:

```py
from utils.webuntishandler import get_lesson_plan
```

<br>
Nun sagt man, auf welches Schlüsselwort der Befehl reagieren soll. Dies definiert man wie folgt:

```py
keywords = ["lessonplan"]
```

<br>
Dann definiert man den Befehl, den der Code später ausgeben soll. Hier sagt man, dass der Code versuchen soll die Stunden für den heutigen Tag zu nehmen und diese in einen String zu packen. Beispeil: "Du hast heute Physik von 8:40 bis 9:25." usw.

```py
def cmdfunction(spktext: str):
    try:
        lesson_plan = get_lesson_plan("today")

        text = "Du hast heute "
        for next_lesson in lesson_plan:
            subjects = ', '.join([subject.long_name for subject in next_lesson.subjects])
            start_time = next_lesson.start.strftime("%H:%M")
            end_time = next_lesson.end.strftime("%H:%M")
            next_text = f"{subjects} von {start_time} bis {end_time}."
            text += next_text + " "
```

<br>
Schließlich soll der Code den zusammengetzen String als value zurückgeben. Sollte es einen Fehler geben und der Code hat keinen String generiert, soll der Code den Error "sst-2" geben. "sst-2" ist in definitions.py angegeben.

```py
        return {
            "error": "",
            "value": text
        }
    except:
        return {
            "error": "sst-2",
            "value": ""
        }
```
<br>
<h4 id="timecmd.py">timecmd.py</h4>

Zuerst importiert man eine Library, die die aktuelle Zeit auslesen kann. Dies macht man wie folgt:

```py
import time as timemod
```
<br>

Nun definiert man wieder das Schlüssenwort, auf das der Befehl hören soll:

```py
keywords = ["time"]
```
<br>

Jetzt definiert man wieder den Befehl, der dann ausgesprochen werden soll. Dieser soll einmal versuchen die aktuelle Stunde von der Library zu bekommen und das andere Mal die Minute. Dies soll er dann in einen String zusammensetzen, der dann zum Beispiel lautet: "Es ist 12 Uhr 30.".

```py
def cmdfunction(spktext: str):
    try:
        hour = timemod.strftime("%H", timemod.localtime())
        minute = timemod.strftime("%M", timemod.localtime())

        text = "Es ist " + hour + " Uhr"
        if minute != "00":
            text += " " + minute
```
<br>

Zuletzt soll der String weiter an das TTS gegeben werden. Sollte etwas schief laufen, soll der Code den Error "time-1" geben. Dieser ist auch in definitions.py zu finden.

```py
        return {
            "error": "",
            "value": text
        }
    except:
        return {
            "error": "time-1",
            "value": ""
        }
```
<br>
<h4 id="weather.py">weather.py</h4>

Zuerst werden die in definitions.py angegebenen weatherapicodes als eine Codeliste importiert. Ebenso wird die Library "requests" genommen.

```py
from utils.definitions import weatherapicodes as codelist
import requests
```
<br>
Nun, wie immer, wird das Schlüsselwort definiert, auf welches der Befehl hören soll.

```py
keywords = ['weather']
```

Jetzt wird der Befehl definiert, der den Text später als String rausgeben soll. Außerdem wird hier definiert, welche API wir verwenden und mit welchem API Key wir Zugang zur API bekommen.

```py
def cmdfunction(spktext: str):
    weather_url = 'http://api.weatherapi.com/v1/current.json'
    api_key = 'X'
```
<br>

Hier definieren wir nun die Parameter, welche Daten zwischen der API und dem Sender ausgetauscht werden sollen. Der Key wurde oben bereits definiert, muss aber anders für die API geschrieben werden. Das "q" definiert hier den Standort des Senders, welche die aktuelle Position von der IP-Addresse des Senders bekommt. "lang" ist hier die Sprache die ausgegeben werden soll.

```py
    try:
        params = {
            'key': api_key,
            'q': 'auto:ip',
            'lang': 'de'
        }
```
<br>
Nun werden hier die benötigten Daten von der API genommen und in Variablen geschrieben, sodass man diese einfacher verwenden kann.

```py
        response = requests.get(weather_url, params=params)
        response.raise_for_status()
        
        weather_data = response.json()
        
        location = weather_data['location']['name']
        country = weather_data['location']['country']
        temp_c = weather_data['current']['temp_c']
        condition_code = weather_data['current']['condition']['code']
        is_day = weather_data['current']['is_day']
```
<br>
Da die API auch auf Tag/Nacht achtet, muss man nun sagen, wann die API uns die Daten für den Tag geben soll und wann für die Nacht.

```py
        condition = codelist[str(condition_code)]['day']


        if (is_day == 0):
            condition = codelist[str(condition_code)]['night']
```
<br>
Hier definieren wir nun, wann im String für die Temperatur "warn" und wann "kalt" gesagt werden soll.

```py
        temphc = 'warm'

        if (temp_c < 10):
            temphc = 'kalt'
        
        if (str(temp_c).index(".")):
            temp_c = str(temp_c).replace("."," komma ")
```
<br>
Nun setzen wir hier den String aus allen Informationen, die wir gesammelt haben, zusammen. Außerden geben wir den zusammengesetzen String zurück. Sollte dies nicht klappen, soll der Code den Error "weather-1" geben. Dieser Error ist in definitions.py angegeben.

```py
        output = "Hier ist das aktuelle Wetter in " + str(location) + ", " + str(country) + ". " + "Es ist " + str(temp_c) + " Grad Celsius " + str(temphc) + " und " + str(condition) + "."

        return {
            "error": "",
            "value": output
        }
    
    except:
        return {
            "error": "weather-1",
            "value": ""
        }
```

<h2 id="kapitel4">4. Entstehung des Projekts</h2>
<p>Es war ziehmlich einfach für uns das richtige Projekt zu finden, anders als im letzen Halbjahr. Die Idee für den Schoolbuddy bekamen wir schon letztes Jahr, während wir an unserem vorherigen Projekt gearbeitet haben. Die Idee hat sich auch direkt als gut umsetzbar herausgestellt, also begannen wir mit der Entwicklung eines Konzeptes für das Projekt. Ohne Konzept und Struktur, würde man sich bei so einem Projekt schnell vertun können.</p>
<p>Schnell wurde auch dieses Mal klar, dass der eine Teil des Projekts zu Anspruchsvoll für alle Teilnehmer der Gruppe sein wird, also haben wir, so wie auch beim letzten Mal, die Arbeit in verschiedene Teile aufgesplittet.</p>
<p>Wärend der eine an dem Backend gearbeitet hat, hat der andere die Aufgabe gehabt, an den Befehlen usw. zu arbeiten. Diese Teile hatten verschiedene Schwierigkeitsstufen, also hat der mehr Erfahrene an den schwierigeren Dingen gearbeitet, während der Andere an den etwas einfacheren Dingen gearbeitet hat.</p>


<h2 id="kapitel5">5. Fazit</h2>
<p>Aktuell können wir noch kein finales Fazit, auf das gesamte Projekt betrachtet, abgeben. Dies ist deswegen, weil wir das Projekt noch nicht vollständig abgeschlossen haben und es noch vieles zu tun gibt. Allerdings können wir schonmal auf das gemachte und vergangene ein Fazit geben.</p>
<p>Die Projektfindung am Anfang hat sich diesmal ziemlich einfach dargestellt, da wir schon bereits vor dem Beginn der neuen Projektperiode, die Idee hatten diesen Alltagshelfer zu entwickeln.</p>
<p>Das Entwickeln des Konzeptes ist etwas anspruchsvoller gewesen, da wir erstmal herrausfinden mussten, welche Arbeitsmaterialien für uns zur Verfügung standen, und welche nicht.</p>
<p>Die eigendliche Umsetzung des Projekts hat prinzipiell erst gerade begonnen und es steht noch der Rest des Halbjahres vor uns. Die ersten Schritte dort hin haben sich als schwierig dargestellt, da das Arbeiten, mit für uns neuen Materialien, Übung und Erfahrung braucht.</p>
<p>Insgesamt kommen wir jedoch gut vorran und das Projekt nähert sich immer weiter seiner Fertigstellung, mit der kurz vor Anfang der Sommerferien 2023 gerechnet wird.</p>


<h2 id="kapitel6">6. Quellen</h2>
<a href="https://github.com/espeak-ng/espeak-ng">ESpeak-ng</a><br>
<a href="https://github.com/thorstenMueller/Thorsten-Voice">Thorsten Voice</a><br>
<a href="https://www.mysql.com/">MySQL</a><br>
Alle weiteren Quellen sind in der Pipfile.lock Datei zu finden.


<h2 id="kapitel7">7. Eigenständigkeitserklärung</h2>

<b>Eigenständigkeitserklärung</b></br>
<p>Wir erklären, dass wir die vorliegende Arbeit selbstständig und ohne Benutzung anderer als den 
angegebenen Hilfsmittel angefertigt und alle Stellen, die wörtlich oder sinngemäß aus 
veröffentlichten oder unveröffentlichten Schriften entnommen wurden, als solche kenntlich 
gemacht haben.</p>
<p>Diese Arbeit wurde nicht, auch nicht auszugsweise, bereits für eine andere Prüfung angefertigt.</p>
